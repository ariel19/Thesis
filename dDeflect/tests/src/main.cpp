#include <cstdio>
#include <QFile>
#include <QDir>
#include <iostream>

//#include <core/file_types/elffile.h>
//#include <core/file_types/pefile.h>

#include <core/file_types/pefile.h>
#include <QCoreApplication>

//void wrapper()
//{
//    int is_dbg = 0;

//    asm();

//    asm("db !__METHOD_DATA___!");

//    asm("mov is_dbg, !__RETURN_VALUE__!");

//    // TODO: akcja
//}

//void wrapper()
//{
//    volatile int is_dbg = 0;

//    asm("push ecx");
//    asm("push eax");
//    asm("push edx");

//    asm("db 0x64, 0x8B, 0x0D, 0x30, 0x00, 0x00, 0x00, 0x31, 0xC0, 0x8A, 0x51, 0x68, 0x80, 0xE2, 0x70, 0x80, 0xFA, 0x70, 0x0F, 0x94, 0xC0");

//    asm("mov byte is_dbg, al");

//    asm("pop edx");
//    asm("pop eax");
//    asm("pop ecx");

//    if(is_dbg)
//        printf("DEBUG!");
//}

// create thread wrapper
//void create_thread() {
//    asm("push eax");
//    asm("push edx");
//    asm("psuh ecx");

//    // create a thread using clone
//    // clone syscall + CLONE_THREAD
//    // stack address: http://linux.die.net/man/2/clone
//    // clone syscall number: 120
//    // documentation: http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html
//    // links: http://nlo.lists.kernelnewbies.narkive.com/npChDJyH/pt-regs-structure-for-sys-clone

//    // ptrace syscall
//    // link: http://mikecvet.wordpress.com/2010/08/14/ptrace-tutorial/
//    asm("mov eax, 26"); // sys_ptrace



//    asm("pop ecx");
//    asm("pop edx");
//    asm("pop eax");
//}

/*QByteArray createFuncLoading32()
{
    QByteArray code;

    unsigned char data[] = {
        0xE8,0x06,0x00,0x00,0x00,0x4B,0x45,0x52,0x4E,0x45,0x4C,0x5E,0x64,0xA1,0x30,0x00,
        0x00,0x00,0x8B,0x40,0x0C,0x8B,0x40,0x14,0x8B,0x50,0x28,0x85,0xD2,0x0F,0x84,0xB3,
        0x00,0x00,0x00,0x31,0xC9,0x83,0xF9,0x06,0x74,0x16,0x0F,0xB6,0x1C,0x0E,0x3A,0x1C,
        0x4A,0x74,0x0A,0x80,0xC3,0x20,0x3A,0x1C,0x4A,0x74,0x02,0xEB,0x15,0x41,0xEB,0xE5,
        0x83,0xC2,0x0C,0x80,0x3A,0x33,0x75,0x0A,0x83,0xC2,0x02,0x80,0x3A,0x32,0x75,0x02,
        0x74,0x04,0x8B,0x00,0xEB,0xC2,0x8B,0x40,0x10,0x50,0x03,0x40,0x3C,0x8B,0x40,0x78,
        0x03,0x04,0x24,0x50,0x8B,0x48,0x18,0x8B,0x40,0x20,0x03,0x44,0x24,0x04,0xE8,0x0E,
        0x00,0x00,0x00,0x47,0x65,0x74,0x50,0x72,0x6F,0x63,0x41,0x64,0x64,0x72,0x65,0x73,
        0x73,0x5E,0x8B,0x7C,0x88,0xFC,0x03,0x7C,0x24,0x04,0x31,0xDB,0x83,0xFB,0x0E,0x74,
        0x13,0x0F,0xB6,0x14,0x1F,0x3A,0x14,0x1E,0x75,0x03,0x43,0xEB,0xEF,0x83,0xE9,0x01,
        0x75,0xE0,0xEB,0x2F,0x5A,0x58,0x8B,0x7A,0x24,0x01,0xC7,0x0F,0xB7,0x7C,0x4F,0xFE,
        0x8B,0x4A,0x1C,0x01,0xC1,0x8B,0x14,0xB9,0x01,0xC2,0x52,0xE8,0x0D,0x00,0x00,0x00,
        0x4C,0x6F,0x61,0x64,0x4C,0x69,0x62,0x72,0x61,0x72,0x79,0x41,0x00,0x50,0xFF,0xD2,
        0x5A,0xEB,0x07,0x83,0xC4,0x08,0x31,0xC0,0x31,0xD2
    };
    code.append(QByteArray((char*)data, sizeof(data)));

    return code;
}*/


//QByteArray create_ep_thread_32(uint32_t oldEP, uint32_t imageBase, uint32_t threadFunc)
//{
//    QByteArray code;

//    code.append(createFuncLoading32());

//    code.append(QByteArray(10, '\x90'));

//    /* create_thread_example.asm */
//    unsigned char data1[] = {
//    0x52,0xE8,0x0D,0x00,0x00,0x00,0x6B,0x65,0x72,0x6E,0x65,0x6C,0x33,0x32,0x2E,0x64,
//    0x6C,0x6C,0x00,0xFF,0xD0,0x5A,0xE8,0x0D,0x00,0x00,0x00,0x43,0x72,0x65,0x61,0x74,
//    0x65,0x54,0x68,0x72,0x65,0x61,0x64,0x00,0x50,0xFF,0xD2,0x89,0xC2,0xBF
//    };
//    code.append((char*)data1, sizeof(data1));
//    code.append((char*)&threadFunc, 4);     // adres do funkcji

//    code.append(QByteArray(10, '\x90'));

//    /* create_thread.asm */
//    unsigned char data2[] = {
//    0x31,0xC0,0x50,0x50,0x50,0x57,0x50,0x50,0xFF,0xD2
//    };
//    code.append((char*)data2, sizeof(data2));

//    code.append(QByteArray(10, '\x90'));

//    uint32_t old_ep = imageBase + oldEP;
//    code.append('\xB8'); // mov eax, old_ep
//    code.append(QByteArray::fromRawData(reinterpret_cast<const char *>(&old_ep), sizeof(uint32_t)));
//    code.append("\xFF\xE0"); // jmp eax

//    return code;
//}

//QByteArray thread_func32()
//{
//    QByteArray code;

//    code.append("\x55\x89\xE5"); // push ebp; mov ebp, esp;
//    code.append(createFuncLoading32());

//    code.append(QByteArray(10, '\x90'));

//    /* thread_example.asm */
//    unsigned char data[] = {
//    0x52,0x50,0x83,0xEC,0x10,0xE8,0x0B,0x00,0x00,0x00,0x75,0x73,0x65,0x72,0x33,0x32,
//    0x2E,0x64,0x6C,0x6C,0x00,0xFF,0x55,0xF8,0x89,0x45,0xF0,0xE8,0x0D,0x00,0x00,0x00,
//    0x6B,0x65,0x72,0x6E,0x65,0x6C,0x33,0x32,0x2E,0x64,0x6C,0x6C,0x00,0xFF,0x55,0xF8,
//    0x89,0x45,0xF4,0xE8,0x0C,0x00,0x00,0x00,0x4D,0x65,0x73,0x73,0x61,0x67,0x65,0x42,
//    0x6F,0x78,0x41,0x00,0xFF,0x75,0xF0,0xFF,0x55,0xFC,0x89,0x45,0xEC,0xE8,0x06,0x00,
//    0x00,0x00,0x53,0x6C,0x65,0x65,0x70,0x00,0xFF,0x75,0xF4,0xFF,0x55,0xFC,0x89,0x45,
//    0xE8,0x68,0x10,0x27,0x00,0x00,0xFF,0x55,0xE8,0x6A,0x00,0x6A,0x00,0xE8,0x03,0x00,
//    0x00,0x00,0x3A,0x29,0x00,0x6A,0x00,0xFF,0x55,0xEC,0xEB,0xE5
//    };

//    code.append((char*)data, sizeof(data));

//    code.append(QByteArray(10, '\x90'));


//    code.append("\x5D\xC3"); // pop ebp; ret;

//    return code;
//}

//QByteArray create_ep_code_64(uint32_t oldEP, uint64_t imageBase)
//{
//    // TODO: przetestowaÄ‡
//    QByteArray code;

//    code.append(QByteArray(10, '\x90'));

//    uint64_t old_ep = imageBase + oldEP;
//    code.append("\x48\xB8"); // movabs rax,oldep
//    code.append(QByteArray::fromRawData(reinterpret_cast<const char *>(&old_ep), sizeof(uint64_t)));
//    code.append("\xFF\xE0"); // jmp eax

//    return code;
//}

int main(int argc, char **argv)
{
    QCoreApplication app(argc, argv);
    //QFile f("C:\\Users\\jablonskim\\Desktop\\Programy\\putty.exe");
    //QFile f("C:\\Windows\\System32\\calc.exe");
    QFile f("C:\\Users\\jablonskim\\Desktop\\peview.exe");

    if(!f.open(QFile::ReadOnly))
        return 1;

    PEFile pe(f.readAll(), QFileInfo(f).absoluteFilePath());

    f.close();

    if(!pe.isValid())
    {
        puts("Bad format!");
        return 1;
    }

    QList<InjectDescription<Register_x86>*> ids;
    //ids.append(new (std::nothrow) InjectDescription<Register_x86>(CallingMethod::EntryPoint, Wrapper<Register_x86>::fromFile(Wrapper<Register_x86>::methodsPath + "create_thread.asm", true)));
    //ids.append(new (std::nothrow) InjectDescription<Register_x86>(CallingMethod::TLS, Wrapper<Register_x86>::fromFile(Wrapper<Register_x86>::methodsPath + "handlers\\message_box.asm")));
    ids.append(new (std::nothrow) InjectDescription<Register_x86>(CallingMethod::Trampoline, Wrapper<Register_x86>::fromFile(Wrapper<Register_x86>::methodsPath + "printf_test.asm")));

    //QList<InjectDescription<Register_x64>*> ids;
    //ids.append(new (std::nothrow) InjectDescription<Register_x64>(CallingMethod::EntryPoint, Wrapper<Register_x64>::fromFile(Wrapper<Register_x64>::methodsPath + "create_thread.asm", true)));
    //ids.append(new (std::nothrow) InjectDescription<Register_x64>(CallingMethod::TLS, Wrapper<Register_x64>::fromFile(Wrapper<Register_x64>::methodsPath + "handlers\\message_box.asm")));

    if(pe.injectCode(ids))
        puts("Success!");
    else
        puts("Failed!");

    qDeleteAll(ids);

    QFile nf("new_example.exe");
    if(!nf.open(QFile::WriteOnly))
        return 1;
    nf.write(pe.getData());
    nf.close();

    puts("OK!");

    return 0;
}
