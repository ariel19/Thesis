<<<<<<< HEAD
#include <cstdio>
#include <QFile>
#include <QDir>
#include <iostream>

#include <core/file_types/elffile.h>
#include <core/file_types/pefile.h>

////void wrapper()
////{
////    int is_dbg = 0;

////    asm();

////    asm("db !__METHOD_DATA___!");

////    asm("mov is_dbg, !__RETURN_VALUE__!");

////    // TODO: akcja
////}

////void wrapper()
////{
////    volatile int is_dbg = 0;

////    asm("push ecx");
////    asm("push eax");
////    asm("push edx");

////    asm("db 0x64, 0x8B, 0x0D, 0x30, 0x00, 0x00, 0x00, 0x31, 0xC0, 0x8A, 0x51, 0x68, 0x80, 0xE2, 0x70, 0x80, 0xFA, 0x70, 0x0F, 0x94, 0xC0");

////    asm("mov byte is_dbg, al");

////    asm("pop edx");
////    asm("pop eax");
////    asm("pop ecx");

////    if(is_dbg)
////        printf("DEBUG!");
////}

//// create thread wrapper
//void create_thread() {
//    asm("push eax");
//    asm("push edx");
//    asm("psuh ecx");

//    // create a thread using clone
//    // clone syscall + CLONE_THREAD
//    // stack address: http://linux.die.net/man/2/clone
//    // clone syscall number: 120
//    // documentation: http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html
//    // links: http://nlo.lists.kernelnewbies.narkive.com/npChDJyH/pt-regs-structure-for-sys-clone

//    // ptrace syscall
//    // link: http://mikecvet.wordpress.com/2010/08/14/ptrace-tutorial/
//    asm("mov eax, 26"); // sys_ptrace



//    asm("pop ecx");
//    asm("pop edx");
//    asm("pop eax");
//}

int main()
{
    std::cout << QDir::currentPath().toStdString() << std::endl;

//    ELF elf("a.out");
//    std::cout << "valid: " << elf.is_valid() << std::endl;
//    std::cout << "segments no: " << elf.get_number_of_segments() << std::endl;
//    for (int i = 0; i < elf.get_number_of_segments(); ++i) {
//        std::cout << "segment {" << i << "}: 0x" << std::hex<< elf.get_ph_seg_offset(i);
//    }

//    QByteArray nops(12, '\x90');
//    Elf64_Addr nva;

//    QByteArray nf = elf.extend_segment(nops, false, nva);

//    if (!elf.set_entry_point(nva, nf))
//        return 1;

//    elf.write_to_file("a2.out", nf);


    /*
    QFile f("example.exe");
    if(!f.open(QFile::ReadOnly))
        return 1;

    PEFile pe(f.readAll());

    f.close();

    if(!pe.isValid())
    {
        puts("Bad format!");
        return 1;
    }

    printf("%d, %d, %d\n", pe.getLastSectionNumberRaw(), pe.getLastSectionNumberMem(), pe.getNumberOfSections());

    for(unsigned int i = 0; i < pe.getNumberOfSections(); ++i)
        printf("Sekcja %u: %u\n", i, pe.getSectionFreeSpace(i));

    QByteArray nd(100, '\x90');
    nd[10] = '\xEB';
    nd[11] = '\xFE';

    unsigned int new_offset, new_mem_offset;
    if(!pe.addNewSection(QString(".test"), nd, new_offset, new_mem_offset) || !pe.setNewEntryPoint(new_mem_offset))
    {
        puts("Failed!");
        return 1;
    }

    printf("Offset: %x, Mem: %x\n", new_offset, new_mem_offset);

    QFile nf("new_example.exe");
    if(!nf.open(QFile::WriteOnly))
        return 1;
    nf.write(pe.getData());
    nf.close();

    puts("OK!");
    */


    return 0;
}
=======
#include <cstdio>
#include <QFile>
#include <QDir>
#include <QVariant>
#include <QDebug>
#include <iostream>

#include <core/file_types/elffile.h>
#include <core/file_types/pefile.h>

// TODO: should be wrapper
int oep_ptrace(const QString &elf_fname, const QString &ptrace_fname, const QString &elf_out) {
    ELF elf(elf_fname);
    qDebug() << "valid: " << elf.is_valid();
    qDebug() << "segments no: " << elf.get_number_of_segments();

    QFile first_test(ptrace_fname);
    if (!first_test.open(QIODevice::ReadOnly))
        return 1;
    QByteArray whole = first_test.readAll();
    // TODO: should be in wrapper after add jump instruction here
    Elf64_Addr oldep;
    if (!elf.get_entry_point(oldep))
        return 1;

    QByteArray jmp;
    if (elf.is_x86() || oldep < 0x100000000) {
        jmp.append(0xb8); // mov eax, addr
        // oldep -= 0x5;
        for(uint i = 0; i < sizeof(Elf32_Addr); ++i) {
            int a = (oldep >> (i * 8) & 0xff);
            jmp.append(static_cast<char>(a));
        }
        jmp.append("\xff\xe0", 2); // jmp eax
    }
    else if (elf.is_x64()) {
        jmp.append("\x48\xb8", 2); // mov rax, addr
        for(uint i = 0; i < sizeof(Elf64_Addr); ++i) {
            int a = (oldep >> (i * 8) & 0xff);
            jmp.append(static_cast<char>(a));
        }
        jmp.append("\xff\xe0", 2);
    }
    else return 1;

    // QByteArray nops(12, '\x90');
    Elf64_Addr nva;

    whole.append(jmp);

    QByteArray nf = elf.extend_segment(whole, true, nva);

    if (!elf.set_entry_point(nva, nf))
        return 1;

    qDebug() << "new entry point: " << QString("0x%1").arg(nva, 0, 16);

    elf.write_to_file(elf_out, nf);

    qDebug() << "saving to file: " << elf_out;

    return 0;
}

int create_thread(const QString &elf_fname, const QString &thread_fname, const QString &elf_out) {
    ELF elf(elf_fname);
    qDebug() << "valid: " << elf.is_valid();
    qDebug() << "segments no: " << elf.get_number_of_segments();

    QFile first_test(thread_fname);
    if (!first_test.open(QIODevice::ReadOnly))
        return 1;
    QByteArray whole = first_test.readAll();
    // TODO: should be in wrapper after add jump instruction here
    Elf64_Addr oldep;
    if (!elf.get_entry_point(oldep))
        return 1;

    QByteArray jmp;
    if (elf.is_x86() || oldep < 0x100000000) {
        jmp.append(0xb8); // mov eax, addr
        // oldep -= 0x5;
        for(uint i = 0; i < sizeof(Elf32_Addr); ++i) {
            int a = (oldep >> (i * 8) & 0xff);
            jmp.append(static_cast<char>(a));
        }
        jmp.append("\xff\xe0", 2); // jmp eax
    }
    else if (elf.is_x64()) {
        jmp.append("\x48\xb8", 2); // mov rax, addr
        for(uint i = 0; i < sizeof(Elf64_Addr); ++i) {
            int a = (oldep >> (i * 8) & 0xff);
            jmp.append(static_cast<char>(a));
        }
        jmp.append("\xff\xe0", 2);
    }
    else return 1;

    // QByteArray nops(12, '\x90');
    Elf64_Addr nva;

    whole.append(jmp);

    QByteArray nf = elf.extend_segment(whole, true, nva);

    if (!elf.set_entry_point(nva, nf))
        return 1;

    qDebug() << "new entry point: " << QString("0x%1").arg(nva, 0, 16);

    elf.write_to_file(elf_out, nf);

    qDebug() << "saving to file: " << elf_out;

    return 0;
}

void test() {
    qDebug() << "=========================================";
    qDebug() << "Testing OEP + ptrace for my 32-bit app...";
    // test oep + ptrace
    if (oep_ptrace("my32", "ptrace", "_my32")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + ptrace for my 32-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + ptrace for my 64-bit app...";
    if (oep_ptrace("my64", "ptrace64", "_my64")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + ptrace for my 64-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + ptrace for derby 32-bit app...";
    // test oep + ptrace
    if (oep_ptrace("derby32", "ptrace", "_derby32")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + ptrace for derby 32-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + ptrace for derby 64-bit app...";
    if (oep_ptrace("derby64", "ptrace64", "_derby64")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + ptrace for derby 64-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + ptrace for edb 64-bit app...";
    if (oep_ptrace("edb", "ptrace64", "_edb64")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + ptrace for edb 64-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + ptrace for dDeflect 64-bit app...";
    if (oep_ptrace("dDeflect", "ptrace64", "_dDeflect64")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + ptrace for dDeflect 64-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + thread for my 32-bit app...";
    // test oep + ptrace
    if (oep_ptrace("my32", "thread", "_my32t")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + thread for my 32-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + thread for my 64-bit app...";
    if (oep_ptrace("my64", "thread64", "_my64t")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + thread for my 64-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + thread for derby 32-bit app...";
    // test oep + ptrace
    if (oep_ptrace("derby32", "thread", "_derby32t")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + thread for derby 32-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + thread for derby 64-bit app...";
    if (oep_ptrace("derby64", "thread64", "_derby64t")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + thread for derby 64-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + thread for edb 64-bit app...";
    if (oep_ptrace("edb", "thread64", "_edb64t")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + thread for edb 64-bit app done";
    qDebug() << "=========================================";

    qDebug() << "Testing OEP + thread for dDeflect 64-bit app...";
    if (oep_ptrace("dDeflect", "thread64", "_dDeflect64t")) {
        qDebug() << "something went wrong :(";
    }
    qDebug() << "Testing OEP + thread for dDeflect 64-bit app done";
}

int test_flagx(const QString &elf_fname, const QString &elf_out) {
    ELF elf(elf_fname);
    qDebug() << "valid: " << elf.is_valid();
    qDebug() << "segments no: " << elf.get_number_of_segments();

    // QByteArray nops(12, '\x90');
    QByteArray nops(5, '\x00');
    // TODO: should be in wrapper after add jump instruction here
    Elf64_Addr oldep;
    if (!elf.get_entry_point(oldep))
        return 1;

    Elf64_Addr nva;

    QByteArray nf = elf.extend_segment(nops, true, nva);

    /*if (!elf.set_entry_point(nva, nf))
        return 1;*/

    qDebug() << "new entry point: " << QString("0x%1").arg(nva, 0, 16);

    elf.write_to_file(elf_out, nf);

    qDebug() << "saving to file: " << elf_out;

    return 0;
}

int main() {
    test();
    // oep_ptrace("test", "ptrace", "test3");
    // test_flagx("a", "a2");

    return 0;
}
>>>>>>> 1b5513daf6be245d37995b844f976d4e6aa21b45
